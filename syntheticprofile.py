def make_synthetic_error_profile(
    N=1000,
    group_col="group",
    group_names=None,
    fields=None,
    error_rates=None,
    error_types=None,
    error_type_dist=None,
    joint_error_probs=None,
    edit_dist_bins=None,
    edit_dist_dist=None,
    description="Synthetic Error Profile (autogenerated by script)",
    profiler_version="assistant-v1",
):
    """
    Create a synthetic error profile dict for use with SyntheticGenerator.

    Parameters
    ----------
    N : int
        Total number of cases.
    group_col : str
        Name of grouping column (e.g. 'ethgroup').
    group_names : list of str
        Names of groups (e.g. ['White', 'Black']).
    fields : list of str
        Fields for error simulation (e.g. ['forename', 'surname']).
    error_rates : dict of dict
        error_rates[group][field]: float (between 0 and 1)
    error_types : list of str
        Error type names (e.g. ['Replacement', 'Typo', ...])
    error_type_dist : dict of dict of dict
        error_type_dist[group][field][error_type]: float (relative freq, sum to 1)
    joint_error_probs : dict of dict
        joint_error_probs[group][combo_string]: float (must sum to 1 per group)
        E.g. combo_string: "((Error,), (Error,))", "((Error,), ('NoError',))", ...
    edit_dist_bins : list of str
        Edit distance bin labels (e.g. ['1','2','3','4','5+'])
    edit_dist_dist : dict of dict of dict
        edit_dist_dist[group][field][bin]: float (must sum to 1)
    """
    # Defaults
    if fields is None:
        fields = ["forename", "surname"]
    if error_types is None:
        error_types = ["Replacement", "Typo"]
    if edit_dist_bins is None:
        edit_dist_bins = ["1", "2", "3", "4", "5+"]

    # "No group" mode: use 'Overall'
    if not group_names:
        group_names = ["Overall"]
        grouped = False
    elif len(group_names) == 1:
        grouped = False
    else:
        grouped = True

    if error_rates is None:
        error_rates = {group_names[0]: {f: 0.1 for f in fields}}
    if error_type_dist is None:
        error_type_dist = {
            group_names[0]: {
                f: {et: 1/len(error_types) for et in error_types}
                for f in fields
            }
        }
    if joint_error_probs is None:
        combos = [
            "((\'NoError\',), (\'NoError\',))",
            "((\'Replacement\',), (\'NoError\',))",
            "((\'NoError\',), (\'Replacement\',))"
        ]
        joint_error_probs = {
            group_names[0]: {
                combos[0]: 0.8,
                combos[1]: 0.1,
                combos[2]: 0.1,
            }
        }
    if edit_dist_dist is None:
        edit_dist_dist = {
            group_names[0]: {
                f: {b: (1.0 if i == 0 else 0.0) for i, b in enumerate(edit_dist_bins)}
                for f in fields
            }
        }

    def build_group_obj(group):
        group_obj = {group_col: group}
        for field in fields:
            errpos = {f"{etype}__none": error_type_dist[group][field][etype] for etype in error_types}
            errpos["NoError__none"] = 1 - error_rates[group][field]
            group_obj[f"{field}_error_position_by_type"] = errpos
            group_obj[f"{field}_edit_distance_distribution"] = edit_dist_dist[group][field]
        group_obj["n_group"] = int(N * (1.0 if not grouped else 1.0 / len(group_names)))
        return group_obj

    # Meta always uses the first (or only) group for structure
    meta_joint = joint_error_probs[group_names[0]]
    meta_dict = {
        "description": description,
        "n_total": N,
        "group_columns": [group_col] if grouped else [],
        "group_value_counts": (
            {group_col: {g: 1/len(group_names) for g in group_names}}
            if grouped else
            {group_col: {group_names[0]: 1.0}}
        ),
        "joint_error_combinations": {
            k: {"prob": v, "rare": v < 0.01} for k, v in meta_joint.items()
        },
        "profiler_version": profiler_version,
    }

    # Add group(s)
    if grouped:
        groups_list = [build_group_obj(g) for g in group_names]
        profile_dict = {
            "meta": meta_dict,
            "groups": groups_list
        }
    else:
        profile_dict = {
            "meta": meta_dict,
            "group": build_group_obj(group_names[0])
        }
    return profile_dict
